#include <WiFi.h>
#include <WebServer.h>
#include <HTTPClient.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <TJpg_Decoder.h>
#include <time.h>

const char* ssid = "Demo";
const char* password = "ejieflorida";

#define RELAY_PIN 12
#define BUTTON_PIN 13
#define TRIGGER_BUTTON_PIN 14
#define BUTTON_CHECK_REMAIN 27

bool relayActive = false;
unsigned long relayStartTime = 0;
bool triggerFlag = false;
unsigned long remainingSeconds = 0;
bool scheduleReceived = false;

#define TFT_CS   5
#define TFT_DC   2
#define TFT_RST  4

WebServer server(80);
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);

bool tft_output(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t *bitmap) {
  tft.drawRGBBitmap(x, y, bitmap, w, h);
  return true;
}

void resizeImage(uint8_t *jpgBuffer, int bufferLength, uint16_t screenWidth, uint16_t screenHeight) {
  uint16_t imgWidth, imgHeight;
  TJpgDec.getJpgSize(&imgWidth, &imgHeight, jpgBuffer, bufferLength);

  if (imgWidth == 0 || imgHeight == 0) {
    Serial.println("No face detected");
    tft.fillScreen(ILI9341_BLACK);
    tft.setCursor(10, 10);
    tft.setTextColor(ILI9341_RED);
    tft.setTextSize(2);
    tft.println("Slow Wifi Connection!");
    return;
  }

  Serial.printf("Original Image size: %d x %d\n", imgWidth, imgHeight);
  TJpgDec.drawJpg(0, 0, jpgBuffer, bufferLength);
}

void handleSetSchedule() {
  if (server.hasArg("plain")) {
    String payload = server.arg("plain");
    Serial.println("Received schedule payload: " + payload);

    int index = payload.indexOf("endTime");
    if (index >= 0) {
      int timeStart = payload.indexOf("\"", index + 9) + 1;
      int timeEnd = payload.indexOf("\"", timeStart);
      String endTimeStr = payload.substring(timeStart, timeEnd);

      int hour = endTimeStr.substring(0, 2).toInt();
      int minute = endTimeStr.substring(3, 5).toInt();
      bool isPM = endTimeStr.indexOf("PM") != -1;

      Serial.printf("Parsed endTime: %02d:%02d %s\n", hour, minute, isPM ? "PM" : "AM");

      if (isPM && hour != 12) hour += 12;
      if (!isPM && hour == 12) hour = 0;

      struct tm timeinfo;
      if (!getLocalTime(&timeinfo)) {
        Serial.println("Failed to get time");
        server.send(500, "text/plain", "Time error");
        return;
      }

      int nowSec = timeinfo.tm_hour * 3600 + timeinfo.tm_min * 60 + timeinfo.tm_sec;
      int targetSec = hour * 3600 + minute * 60;
      remainingSeconds = (targetSec > nowSec) ? (targetSec - nowSec) : 0;
      scheduleReceived = true;

      Serial.printf("Current time: %02d:%02d:%02d\n", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
      Serial.printf("Remaining seconds set to: %lu\n", remainingSeconds);

      server.send(200, "text/plain", "Schedule received");
    } else {
      Serial.println("Invalid schedule format");
      server.send(400, "text/plain", "Invalid format");
    }
  } else {
    Serial.println("No schedule data received");
    server.send(400, "text/plain", "No data");
  }
}

void handleOpenRelay() {
  if (server.method() == HTTP_OPTIONS) {
    server.sendHeader("Access-Control-Allow-Origin", "*");
    server.sendHeader("Access-Control-Allow-Methods", "GET, POST");
    server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
    server.send(200);
    return;
  }

  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");

  if (!relayActive) {
    digitalWrite(RELAY_PIN, HIGH);
    relayStartTime = millis();
    relayActive = true;
    Serial.println("Relay ON (Web)");
    server.send(200, "text/plain", "Relay activated");
  } else {
    Serial.println("Relay already active");
    server.send(200, "text/plain", "Relay already active");
  }
}

void handleShouldStart() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.send(200, "text/plain", triggerFlag ? "1" : "0");
  Serial.printf("Trigger flag sent: %d\n", triggerFlag ? 1 : 0);
  triggerFlag = false;
}

void handleGetRemaining() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.send(200, "text/plain", String(remainingSeconds));
  Serial.printf("Remaining seconds sent: %lu\n", remainingSeconds);
}

void fetchAndRenderJPG(const char *url) {
  HTTPClient http;
  http.begin(url);
  int httpCode = http.GET();

  if (httpCode == HTTP_CODE_OK) {
    WiFiClient *stream = http.getStreamPtr();
    const int maxSize = 30000;
    uint8_t *jpgBuffer = (uint8_t *)malloc(maxSize);
    if (!jpgBuffer) {
      Serial.println("Memory allocation failed");
      return;
    }

    int index = 0;
    while (http.connected() && stream->available() && index < maxSize) {
      int c = stream->read();
      if (c < 0) break;
      jpgBuffer[index++] = (uint8_t)c;
    }

    tft.fillScreen(ILI9341_BLACK);
    resizeImage(jpgBuffer, index, tft.width(), tft.height());
    free(jpgBuffer);
  } else {
    tft.fillScreen(ILI9341_BLACK);
    tft.setCursor(10, 60);
    tft.setTextColor(ILI9341_RED);
    tft.setTextSize(2);
    tft.println("Image load failed");
    Serial.printf("Image fetch failed with code: %d\n", httpCode);
  }

  http.end();
}

void setup() {
  Serial.begin(115200);

  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW);

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(TRIGGER_BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUTTON_CHECK_REMAIN, INPUT_PULLUP);

  tft.begin();
  tft.setRotation(3);
  tft.fillScreen(ILI9341_BLACK);
  tft.setCursor(10, 10);
  tft.setTextColor(ILI9341_WHITE);
  tft.setTextSize(2);
  tft.println("Connecting WiFi...");

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\nWiFi connected");
  Serial.println(WiFi.localIP());

  configTime(0, 0, "pool.ntp.org", "time.nist.gov");

  TJpgDec.setCallback(tft_output);
  TJpgDec.setSwapBytes(false);

  server.on("/open", handleOpenRelay);
  server.on("/shouldStart", handleShouldStart);
  server.on("/setSchedule", handleSetSchedule);
  server.on("/getRemaining", handleGetRemaining);
  server.begin();

  Serial.println("HTTP server started");
}

unsigned long lastImageUpdate = 0;
const unsigned long imageInterval = 1000;
unsigned long lastSecond = 0;

void loop() {
  server.handleClient();

  if (digitalRead(BUTTON_CHECK_REMAIN) == LOW && !relayActive) {
    if (remainingSeconds > 0) {
      digitalWrite(RELAY_PIN, HIGH);
      relayStartTime = millis();
      relayActive = true;
      Serial.println("Relay ON (Button D27 with time check)");
    } else {
      Serial.println("Relay activation denied (Button D27): no remaining time");
    }
    delay(300);
  }

  if (digitalRead(BUTTON_PIN) == LOW && !relayActive) {
    digitalWrite(RELAY_PIN, HIGH);
    relayStartTime = millis();
    relayActive = true;
    Serial.println("Relay ON (Button D13 without time check)");
    delay(300);
  }

  if (digitalRead(TRIGGER_BUTTON_PIN) == LOW) {
    triggerFlag = true;
    Serial.println("Trigger flag set (GPIO 14)");
    delay(300);
  }

  if (digitalRead(BUTTON_CHECK_REMAIN) == LOW) {
    Serial.printf("Remaining time: %lus\n", remainingSeconds);
    delay(300);
  }

  if (relayActive && (millis() - relayStartTime >= 5000)) {
    digitalWrite(RELAY_PIN, LOW);
    relayActive = false;
    Serial.println("Relay OFF (timeout)");
  }

  if (scheduleReceived && millis() - lastSecond >= 1000) {
    lastSecond = millis();
    if (remainingSeconds > 0) remainingSeconds--;
  }

  if (millis() - lastImageUpdate >= imageInterval) {
    fetchAndRenderJPG("http://192.168.61.49/frame.jpg");
    lastImageUpdate = millis();
  }
}
